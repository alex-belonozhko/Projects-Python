# task#1
# Если выписать все натуральные числа меньше 10, кратные 3 или 5, то получим 3, 5, 6 и 9. Сумма этих чисел равна 23.
# Найдите сумму всех чисел меньше 1000, кратных 3 или 5.

# u = 0
# for i in range(1000):
#     if (i % 3 == 0) or (i % 5 == 0):
#         u += i
#         print(i)
#
# print(u)

# task#2
# Каждый следующий элемент ряда Фибоначчи получается при сложении двух предыдущих. Начиная с 1 и 2, первые 10 элементов будут:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# Найдите сумму всех четных элементов ряда Фибоначчи, которые не превышают четыре миллиона.

# pred = 2
# predpred = 1
# sum = 0
# for i in range(1, 100):
#     if i == 1:
#         print(i)
#     elif i == 2:
#         sum += i
#         print(i)
#     else:
#         i = pred + predpred
#         predpred = pred
#         pred = i
#         if i % 2 == 0:
#             sum += i
#         if i > 4000000:
#             break
#         print(i)
#
# print(sum)

# task#3
# Простые делители числа 13195 - это 5, 7, 13 и 29.
# Каков самый большой делитель числа 600851475143, являющийся простым числом?
# Изменил число на 1457 потому что слишком долго считает
# Задача в теории решаеться 2-ма способами в первом я сам написал код для вычисления
# Второй код я нашел на сайте ( типа правильный ) Но стоит просто ввести число которое
# будет умножением 2-х простых чисел и мы увидим что моя прога выводит большее а код из инета меньшее
# Поэтому считаю свой код правильным !!! Хотя задачу с 600851475143 посчитал код с инета правильно

# Мой код 1

# def issimple(a):
#     WasDivided = 0
#     lst = []
#     for i in range(2, a):
#         if a % i == 0:
#             for j in range(2, i):
#                 if i % j == 0:
#                     WasDivided += 1
#                     break
#             if WasDivided == 0:
#                 lst.append(i)
#             else:
#                 WasDivided = 0
#     return lst
# a=issimple(1457)
# print(max(a))

# Мой код 2
# Лучшая функция для нахождения простого числа
# def is_simple(Number):
#     for i in range(2, Number):
#         if Number % i == 0:
#             return False
#     return True
#
# def funk(a):
#     ListSimpleNumbers = []
#     for Number in range(2, a+1):
#         if is_simple(Number):
#             ListSimpleNumbers.append(Number)
#             print(max(ListSimpleNumbers))
#     return ListSimpleNumbers
#
# a=funk(600851475143)
# print(max(a))

# Код из инета

# import math
# def issimple(a):
#     r=math.ceil(math.sqrt(a))
#     lst=[]
#     for i in range(3,r):
#         if a%i==0:
#             if issimple(i)==[]:
#                 lst.append(i)
#     return lst
# r=issimple(1457)
# print(max(r))

# task#4
# Число-палиндром с обеих сторон (справа налево и слева направо) читается одинаково.
# Самое большое число-палиндром, полученное умножением двух двузначных чисел – 9009 = 91 × 99.
# Найдите самый большой палиндром, полученный умножением двух трехзначных чисел.

#Первый способ ( Я тестил))) )

# FirstNumber = 999
# SecondNumber = 999
# ResultMultiply = 0
# AnswerNumber = 0
# listPolindroms = []
# while FirstNumber >= 100 and SecondNumber >= 100 > 0:
#     ResultMultiply = FirstNumber * SecondNumber
#     list = []
#     while ResultMultiply > 0:
#         list.append(ResultMultiply % 10)
#         ResultMultiply //= 10
#     list.reverse()
#     if len(list) > 5:
#         if list[0] == list[5]:
#             if list[1] == list[4]:
#                 if list[2] == list[3]:
#                     listPolindroms.append(int(''.join(map(str, list))))
#     elif len(list) > 4 and len(list) < 6:
#         if list[0] == list[4]:
#             if list[1] == list[3]:
#                 listPolindroms.append(int(''.join(map(str, list))))
#     if SecondNumber > 100:
#         SecondNumber -= 1
#     else:
#         FirstNumber -= 1
#         SecondNumber = 999
#     if FirstNumber < 100:
#         break
#
# print(max(listPolindroms))

# Второй спооб ( Четкий из инета )
#
# def is_polindrom(num):
#     raw=str(num)
#     r_num=int(raw[::-1])
#     if num==r_num:
#         return True
#     else:
#         return False
#
# pol = []
# for i in range(100, 1000):
#     for j in range(100, 1000):
#         if is_polindrom(i * j) == True:
#             pol.append(i * j)
# print(max(pol))

# task#5
# 2520 - самое маленькое число, которое делится без остатка на все числа от 1 до 10.
# Какое самое маленькое число делится нацело на все числа от 1 до 20?

# Number = 2520
# t = True
# # Не проверяю на 1, 2, 5, 10, 20 чтобы увеличить производительность
# r = (3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 16, 17, 18, 19)
# while t is True:
#     for j in r:
#         if Number % j == 0:
#             t = False
#         else:
#             t = True
#             break
#     if t is True:
#         Number += 10
#
# print(Number)

# task#6
# Сумма квадратов первых десяти натуральных чисел равна
# 1^2 + 2^2 + ... + 10^2 = 385
# Квадрат суммы первых десяти натуральных чисел равен
# (1 + 2 + ... + 10)^2 = 55^2 = 3025
# Следовательно, разность между суммой квадратов и квадратом суммы первых десяти натуральных чисел составляет 3025 − 385 = 2640.
# Найдите разность между суммой квадратов и квадратом суммы первых ста натуральных чисел.

# SquareSumm = 0
# SummSquares = 0
#
# for Number in range(1, 100+1):
#     SquareSumm += Number
# SquareSumm *= SquareSumm
#
# for Number in range(1, 100+1):
#     SquareNumbers = Number**2
#     SummSquares += SquareNumbers
#
# Difference = SquareSumm - SummSquares
#
# print(Difference)

# task#7
# Выписав первые шесть простых чисел, получим 2, 3, 5, 7, 11 и 13. Очевидно, что 6-ое простое число - 13.
# Какое число является 10001-ым простым числом?

# Первый способ ( медленнее )

# t = True
# Number = 5
# SimpleNumber = 0
# WasDivided = 0
# CountSimpleNumber = 2

# while t is True:
#     for j in range(2, Number):
#         if Number % j == 0:
#             WasDivided += 1
#             break
#     print(Number)
#     if WasDivided == 0:
#         SimpleNumber = Number
#         CountSimpleNumber += 1
# # Увеличиваю число на 2 так как Простое число всегда не четное
# # ( хотя это при тесте вообще не увеличило оптимизацию )
#         Number += 2
#     else:
#         Number += 2
#         WasDivided = 0
#     if CountSimpleNumber == 10001:
#         t = False
#
# print(SimpleNumber)

# Второй способ ( Быстрее )

# import math

# def issimple(n):
#     for i in range(2, n):
#         if n % i == 0:
#             return False
#     return True
#
# n = 5
# s = [2, 3]
# while True:
#     if issimple(n) is True:
#         s.append(n)
#         print(len(s))
#     if len(s) == 10001:
#         break
#     n += 2
#
# print(max(s))

# task#8
# Наибольшее произведение четырех последовательных цифр в нижеприведенном 1000-значном числе равно 9 × 9 × 8 × 9 = 5832.
# 73167176531330624919225119674426574742355349194934
# 96983520312774506326239578318016984801869478851843
# 85861560789112949495459501737958331952853208805511
# 12540698747158523863050715693290963295227443043557
# 66896648950445244523161731856403098711121722383113
# 62229893423380308135336276614282806444486645238749
# 30358907296290491560440772390713810515859307960866
# 70172427121883998797908792274921901699720888093776
# 65727333001053367881220235421809751254540594752243
# 52584907711670556013604839586446706324415722155397
# 53697817977846174064955149290862569321978468622482
# 83972241375657056057490261407972968652414535100474
# 82166370484403199890008895243450658541227588666881
# 16427171479924442928230863465674813919123162824586
# 17866458359124566529476545682848912883142607690042
# 24219022671055626321111109370544217506941658960408
# 07198403850962455444362981230987879927244284909188
# 84580156166097919133875499200524063689912560717606
# 05886116467109405077541002256983155200055935729725
# 71636269561882670428252483600823257530420752963450
# Найдите наибольшее произведение тринадцати последовательных цифр в данном числе.

# Первый способ

# list = []
# OurNumber = ('73167176531330624919225119674426574742355349194934'
#             '96983520312774506326239578318016984801869478851843'
#             '85861560789112949495459501737958331952853208805511'
#             '12540698747158523863050715693290963295227443043557'
#             '66896648950445244523161731856403098711121722383113'
#             '62229893423380308135336276614282806444486645238749'
#             '30358907296290491560440772390713810515859307960866'
#             '70172427121883998797908792274921901699720888093776'
#             '65727333001053367881220235421809751254540594752243'
#             '52584907711670556013604839586446706324415722155397'
#             '53697817977846174064955149290862569321978468622482'
#             '83972241375657056057490261407972968652414535100474'
#             '82166370484403199890008895243450658541227588666881'
#             '16427171479924442928230863465674813919123162824586'
#             '17866458359124566529476545682848912883142607690042'
#             '2421902267105562632111110937054421750694165896040'
#             '807198403850962455444362981230987879927244284909188'
#             '8458015616609791913387549920052406368991256071760'
#             '605886116467109405077541002256983155200055935729725'
#             '71636269561882670428252483600823257530420752963450')
#
# while OurNumber != 0:
#     OurNumber = int(OurNumber)
#     list.append(OurNumber % 10)
#     OurNumber //= 10
# list.reverse()
#
# def funk(list):
#     multy = 1
#     count = 0
#     for i in list:
#         multy *= i
#         count += 1
#         if count == 13:
#             count = 0
#             break
#     return multy
#
# LargestNumber = 0
# t = True
# while t is True:
#     Number = funk(list)
#     if list.__len__() == 12:
#         break
#     else:
#         list.pop(0)
#     if Number > LargestNumber:
#         LargestNumber = Number
# print(LargestNumber)

# Второй способ

# arg = ('73167176531330624919225119674426574742355349194934'
#             '96983520312774506326239578318016984801869478851843'
#             '85861560789112949495459501737958331952853208805511'
#             '12540698747158523863050715693290963295227443043557'
#             '66896648950445244523161731856403098711121722383113'
#             '62229893423380308135336276614282806444486645238749'
#             '30358907296290491560440772390713810515859307960866'
#             '70172427121883998797908792274921901699720888093776'
#             '65727333001053367881220235421809751254540594752243'
#             '52584907711670556013604839586446706324415722155397'
#             '53697817977846174064955149290862569321978468622482'
#             '83972241375657056057490261407972968652414535100474'
#             '82166370484403199890008895243450658541227588666881'
#             '16427171479924442928230863465674813919123162824586'
#             '17866458359124566529476545682848912883142607690042'
#             '2421902267105562632111110937054421750694165896040'
#             '807198403850962455444362981230987879927244284909188'
#             '8458015616609791913387549920052406368991256071760'
#             '605886116467109405077541002256983155200055935729725'
#             '71636269561882670428252483600823257530420752963450')
#
# def arg_mult(b,a):
#     s=1
#     while b<=a:
#         s*=int(arg[b])
#         b+=1
#     return s
#
# def get_args(n):
#     res=[]
#     for i in range(0,len(arg)-(n-1)):
#         res.append(arg_mult(i,i+(n-1)))
#     return res
#
# print(max(get_args(13)))

# task#9
# Тройка Пифагора - три натуральных числа a < b < c, для которых выполняется равенство
# a^2 + b^2 = c^2
# Например, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
# Существует только одна тройка Пифагора, для которой a + b + c = 1000.
# Найдите произведение abc.

# Мой код

# import math
#
# def funk(a, b):
#     c = math.sqrt(a**2 + b**2)
#     if a + b + c == 1000:
#         return True
#     else:
#         return False
#
# a = 1
# b = 2
#
#
# while a < 500:
#     if b < 500:
#         if funk(a, b):
#             print(a, b)
#             break
#         else:
#             b += 1
#     else:
#         if funk(a, b):
#             print(a, b)
#             break
#         else:
#             a += 1
#             b = a + 1
#
# Answer = (int (math.sqrt(a**2 + b**2) * a * b))
# print(Answer)

# Код из ответов

# def listmult(lst):
#     s=1
#     for i in lst:
#         s*=i
#     return s
#
# def fibs(stop):
#     fib=[]
#     while True:
#         for n in range(1,stop):
#             for m in range(2,stop):
#                 if m>n:
#                     fib=[2*n*m,(m**2)-(n**2),(m**2)+(n**2)]
#                     if sum(fib)==stop:
#                         return listmult(fib)
# print(fibs(1000))

# task#10
# Сумма простых чисел меньше 10 равна 2 + 3 + 5 + 7 = 17.
# Найдите сумму всех простых чисел меньше двух миллионов.

# Мой код ( очень долго выполняет )

import math

# def is_simple(Number):
#     for i in range(2, Number):
#         if Number % i == 0:
#             return False
#     return True
#
# ListSimpleNumbers = []
# for Number in range(2, 2000000+1):
#     if is_simple(Number):
#         ListSimpleNumbers.append(Number)
#         print(max(ListSimpleNumbers))
#
# print(sum(ListSimpleNumbers))

# Код из инета
# Сделано по алгоритму Решето Ератосфена

# def eratosthen(n):
#     sieve = list(range(n))
#     sieve[1] = 0
#     for i in sieve[2:]:
#         for j in range(i + i, len(sieve), i):
#             sieve[j] = 0
#     return sieve

# print(sum(eratosthen(2000000)))

